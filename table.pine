// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo

//@version=5
indicator("Nadaraya-Watson Smoothers and Supply/Demand Alerts", overlay=true, max_boxes_count = 500, max_bars_back = 500)

// Parametreler
bw = input.float(8., 'Bandwidth', minval = 0)
src = input(close, 'Source')
repaint = input(true, 'Repainting Smoothing', tooltip = 'Repainting is an effect where the indicators historical output is subject to change over time. Disabling repainting will cause the indicator to output the endpoint of the estimator')

// Style
upCss = input.color(color.teal, 'Colors', inline = 'inline1', group = 'Style')
dnCss = input.color(color.red, '', inline = 'inline1', group = 'Style')

// Gaussian window
gauss(x, bw) => math.exp(-(math.pow(x, 2)/(bw * bw * 2)))

// End point method
var coefs = array.new_float(0)
var den = 0.

if barstate.isfirst and not repaint
    for i = 0 to 499
        w = gauss(i, bw)
        array.push(coefs, w)

    den := array.sum(coefs)

out = 0.
if not repaint
    for i = 0 to 499
        out += src[i] * array.get(coefs, i)
out /= den

// Compute and display NWE
float y2 = na
float y1 = na
float y1_d = na

if barstate.islast and repaint
    for i = 0 to math.min(499, bar_index - 1)
        sum = 0.
        sumw = 0.
        for j = 0 to math.min(499, bar_index - 1)
            w = gauss(i - j, bw)
            sum += src[j] * w
            sumw += w

        y2 := sum / sumw
        d = y2 - y1

        if d * y1_d < 0
            label.new(bar_index-i+1, src[i], y1_d < 0 ? '▲' : '▼'
              , color = color(na)
              , style = y1_d < 0 ? label.style_label_up : label.style_label_down
              , textcolor = y1_d < 0 ? upCss : dnCss
              , textalign = text.align_center)

        y1 := y2
        y1_d := d

plot(repaint ? na : out, 'NWE Endpoint Estimator', out > out[1] ? upCss : dnCss)


// Supply and Demand Parameters
per = input.float(10., 'Threshold %', minval = 0, maxval = 100)
div = input.int(50, 'Resolution'    , minval = 2, maxval = 500)
tf  = input.timeframe('', 'Intrabar TF')

//Colors
showSupply = input(true ,'Supply', inline = 'supply', group = 'Style')
supplyCss  = input(#2157f3, '', inline = 'supply', group = 'Style')
supplyArea = input(true ,'Area', inline = 'supply', group = 'Style')
supplyAvg  = input(true ,'Average', inline = 'supply', group = 'Style')
supplyWavg = input(true ,'Weighted', inline = 'supply', group = 'Style')

showEqui   = input(true ,'Equilibrium', inline = 'equi', group = 'Style')
equiCss    = input(color.gray, '', inline = 'equi', group = 'Style')
equiAvg    = input(true ,'Average', inline = 'equi', group = 'Style')
equiWavg   = input(true ,'Weighted', inline = 'equi', group = 'Style')

showDemand = input(true ,'Demand', inline = 'demand', group = 'Style')
demandCss  = input(#ff5d00, '', inline = 'demand', group = 'Style')
demandArea = input(true ,'Area', inline = 'demand', group = 'Style')
demandAvg  = input(true ,'Average', inline = 'demand', group = 'Style')
demandWavg = input(true ,'Weighted', inline = 'demand', group = 'Style')

// UDT's
type bin
    float lvl
    float prev
    float sum
    float prev_sum
    float csum
    float avg
    bool isreached

type area
    box  bx
    line avg 
    line wavg 

// Functions
n = bar_index

get_hlv()=> [high, low, volume]

method set_area(area id, x1, top, btm, avg, wavg, showArea, showAvg, showWavg)=>
    if showArea
        id.bx.set_lefttop(x1, top)
        id.bx.set_rightbottom(n, btm)    
    
    if showAvg
        id.avg.set_xy1(x1, avg)
        id.avg.set_xy2(n, avg)
    
    if showWavg
        id.wavg.set_xy1(x1, wavg)
        id.wavg.set_xy2(n, wavg)

// Main variables
var max  = 0. 
var min  = 0.
var x1   = 0
var csum = 0.

// Intrabar data
[highs, lows, vols] = request.security_lower_tf(syminfo.tickerid, tf, get_hlv())


// Init on left bar
if time == chart.left_visible_bar_time
    max := high
    min := low
    csum := volume
    x1 := n
else // Accumulate
    max := math.max(high, max)
    min := math.min(low, min)
    csum += volume

// Set zones
var supply_area = area.new(
  box.new(na, na, na, na, na, bgcolor = color.new(supplyCss, 80))
  , line.new(na, na, na, na, color = supplyCss)
  , line.new(na, na, na, na, color = supplyCss, style = line.style_dashed))

var demand_area = area.new(
  box.new(na, na, na, na, na, bgcolor = color.new(demandCss, 80))
  , line.new(na, na, na, na, color = demandCss)
  , line.new(na, na, na, na, color = demandCss, style = line.style_dashed))

var equi  = line.new(na, na, na, na, color = equiCss)
var wequi = line.new(na, na, na, na, color = equiCss, style = line.style_dashed)

var float supply_wavg = na
var float demand_wavg = na

if time == chart.right_visible_bar_time
    r = (max - min) / div
    supply = bin.new(max, max, 0, 0, 0, 0, false)
    demand = bin.new(min, min, 0, 0, 0, 0, false)

    // Loop through intervals
    for i = 0 to div-1
        supply.lvl -= r
        demand.lvl += r

        // Accumulated volume column
        if not supply.isreached and showSupply and supplyArea
            box.new(x1, supply.prev, x1 + int(supply.sum / csum * (n - x1)), supply.lvl, na
              , bgcolor = color.new(supplyCss, 50))
        
        if not demand.isreached and showDemand and demandArea
            box.new(x1, demand.lvl, x1 + int(demand.sum / csum * (n - x1)), demand.prev, na
              , bgcolor = color.new(demandCss, 50))
        
        // Loop through bars
        for j = 0 to (n - x1)-1
            // Loop through intrabars
            for k = 0 to (array.size(vols[j])-1)
                // Accumulate if within upper interval
                supply.sum += (highs[j][k] > supply.lvl and highs[j][k] < supply.prev ? vols[j][k] : 0)
                supply.avg += supply.lvl * (supply.sum - supply.prev_sum)
                supply.csum += supply.sum - supply.prev_sum
                supply.prev_sum := supply.sum

                // Accumulate if within lower interval
                demand.sum += (lows[j][k] < demand.lvl and lows[j][k] > demand.prev ? vols[j][k] : 0)
                demand.avg += demand.lvl * (demand.sum - demand.prev_sum)
                demand.csum += demand.sum - demand.prev_sum
                demand.prev_sum := demand.sum

                
            // Test if supply accumulated volume exceed threshold and set box
            if supply.sum / csum * 100 > per and not supply.isreached
                avg = math.avg(max, supply.lvl)
                supply_wavg := supply.avg / supply.csum

                // Set Box/Level coordinates
                if showSupply
                    supply_area.set_area(x1, max, supply.lvl, avg, supply_wavg, supplyArea, supplyAvg, supplyWavg)

                supply.isreached := true
            
            // Test if demand accumulated volume exceed threshold and set box
            if demand.sum / csum * 100 > per and not demand.isreached and showDemand
                avg = math.avg(min, demand.lvl)
                demand_wavg := demand.avg / demand.csum
                
                // Set Box/Level coordinates
                if showDemand
                    demand_area.set_area(x1, demand.lvl, min, avg, demand_wavg, demandArea, demandAvg, demandWavg)

                demand.isreached := true
            
            if supply.isreached and demand.isreached
                break
        
        if supply.isreached and demand.isreached and showEqui
            // Set equilibrium
            if equiAvg
                avg = math.avg(max, min)
                equi.set_xy1(x1, avg)
                equi.set_xy2(n, avg)
            
            // Set weighted equilibrium
            if equiWavg
                wavg = math.avg(supply_wavg, demand_wavg)
                wequi.set_xy1(x1, wavg)
                wequi.set_xy2(n, wavg)

            break
        
        supply.prev := supply.lvl
        demand.prev := demand.lvl

// Tablo İşlemleri
var tableColor = input.color(title="Tablo Rengi: ", defval=color.rgb(0, 175, 200, 20), group="Tablo Ayarları")  
var tableTextHeaderColor = input.color(title="Yazı Rengi: ", defval=color.rgb(255, 255, 0, 0), group="Tablo Ayarları")
var tableBGColor = input.color(title="Arkaplan Rengi: ", defval=color.rgb(0, 255, 0, 90), group="Tablo Ayarları")

calculate() =>
    value = false
    if (y2 - y1) * y1_d < 0
        value := true
    value

calculate2() =>
    value = false
    if (close > supply_wavg or close < demand_wavg)
        value := true
    value

showFunc() =>
    calculate() or calculate2()

buyArr = array.new_string(0)

sb1 = request.security('CRYPTO:BLZUSD', timeframe.period, showFunc())
sb2 = request.security('MEXC:AUCTIONUSDT', timeframe.period, showFunc())
sb3 = request.security('CRYPTO:LSKUSD', timeframe.period, showFunc())
sb4 = request.security('GATEIO:MBOXUSDT', timeframe.period, showFunc())
sb5 = request.security('BINANCE:MAVUSDT', timeframe.period, showFunc())
sb6 = request.security('CRYPTO:ZRXUSD', timeframe.period, showFunc())
sb7 = request.security('BINANCE:HOOKUSDT', timeframe.period, showFunc())
sb8 = request.security('BINANCE:DYDXUSDT', timeframe.period, showFunc())
sb9 = request.security('BINANCE:NTRNUSDT', timeframe.period, showFunc())
sb10 = request.security('MEXC:GTCUSDT', timeframe.period, showFunc())
sb11 = request.security('MEXC:RDNTUSDT', timeframe.period, showFunc())
sb12 = request.security('OKX:DGBUSDT', timeframe.period, showFunc())
sb13 = request.security('CRYPTO:CELOUSD', timeframe.period, showFunc())
sb14 = request.security('CRYPTO:PEPEUSD', timeframe.period, showFunc())
sb15 = request.security('GATEIO:MDTUSDT', timeframe.period, showFunc())
sb16 = request.security('MEXC:BLURUSDT', timeframe.period, showFunc())
sb17 = request.security('GATEIO:FLOKIUSDT', timeframe.period, showFunc())
sb18 = request.security('GATEIO:ENSUSDT', timeframe.period, showFunc())
sb19 = request.security('CRYPTO:EGLDUSD', timeframe.period, showFunc())
sb20 = request.security('MEXC:PENDLEUSDT', timeframe.period, showFunc())
sb21 = request.security('GATEIO:YGGUSDT', timeframe.period, showFunc())
sb22 = request.security('BINANCE:APEUSDT', timeframe.period, showFunc())
sb23 = request.security('BINANCE:CYBERUSDT', timeframe.period, showFunc())
sb24 = request.security('BINANCE:REEFUSDT', timeframe.period, showFunc())
sb25 = request.security('MEXC:HFTUSDT', timeframe.period, showFunc())
sb26 = request.security('MEXC:BAKEUSDT', timeframe.period, showFunc())
sb27 = request.security('CRYPTO:LOOMUSD', timeframe.period, showFunc())
sb28 = request.security('GATEIO:MOVRUSDT', timeframe.period, showFunc())
sb29 = request.security('CRYPTO:STORJUSD', timeframe.period, showFunc())
sb30 = request.security('MEXC:HIFIUSDT', timeframe.period, showFunc())
sb31 = request.security('GATEIO:IOTXUSDT', timeframe.period, showFunc())
sb32 = request.security('MEXC:KSMUSDT', timeframe.period, showFunc())
sb33 = request.security('GATEIO:FILUSDT', timeframe.period, showFunc())
sb34 = request.security('BINANCE:WLDUSDT', timeframe.period, showFunc())
sb35 = request.security('CRYPTO:GMTUSD', timeframe.period, showFunc())
sb36 = request.security('MEXC:IMXUSDT', timeframe.period, showFunc())
sb37 = request.security('BINANCE:STXUSDT', timeframe.period, showFunc())
sb38 = request.security('BINANCE:FLMUSDT', timeframe.period, showFunc())
sb39 = request.security('MEXC:JASMYUSDT', timeframe.period, showFunc())
sb40 = request.security('MEXC:ACHUSDT', timeframe.period, showFunc())

if sb1
    array.push(buyArr, 'CRYPTO:BLZUSD')
if sb2
    array.push(buyArr, 'MEXC:AUCTIONUSDT')
if sb3
    array.push(buyArr, 'CRYPTO:LSKUSD')
if sb4
    array.push(buyArr, 'GATEIO:MBOXUSDT')
if sb5
    array.push(buyArr, 'BINANCE:MAVUSDT')
if sb6
    array.push(buyArr, 'CRYPTO:ZRXUSD')
if sb7
    array.push(buyArr, 'BINANCE:HOOKUSDT')
if sb8
    array.push(buyArr, 'BINANCE:DYDXUSDT')
if sb9
    array.push(buyArr, 'BINANCE:NTRNUSDT')
if sb10
    array.push(buyArr, 'MEXC:GTCUSDT')
if sb11
    array.push(buyArr, 'MEXC:RDNTUSDT')
if sb12
    array.push(buyArr, 'OKX:DGBUSDT')
if sb13
    array.push(buyArr, 'CRYPTO:CELOUSD')
if sb14
    array.push(buyArr, 'CRYPTO:PEPEUSD')
if sb15
    array.push(buyArr, 'GATEIO:MDTUSDT')
if sb16
    array.push(buyArr, 'MEXC:BLURUSDT')
if sb17
    array.push(buyArr, 'GATEIO:FLOKIUSDT')
if sb18
    array.push(buyArr, 'GATEIO:ENSUSDT')
if sb19
    array.push(buyArr, 'CRYPTO:EGLDUSD')
if sb20
    array.push(buyArr, 'MEXC:PENDLEUSDT')
if sb21
    array.push(buyArr, 'GATEIO:YGGUSDT')
if sb22
    array.push(buyArr, 'BINANCE:APEUSDT')
if sb23
    array.push(buyArr, 'BINANCE:CYBERUSDT')
if sb24
    array.push(buyArr, 'BINANCE:REEFUSDT')
if sb25
    array.push(buyArr, 'MEXC:HFTUSDT')
if sb26
    array.push(buyArr, 'MEXC:BAKEUSDT')
if sb27
    array.push(buyArr, 'CRYPTO:LOOMUSD')
if sb28
    array.push(buyArr, 'GATEIO:MOVRUSDT')
if sb29
    array.push(buyArr, 'CRYPTO:STORJUSD')
if sb30
    array.push(buyArr, 'MEXC:HIFIUSDT')
if sb31
    array.push(buyArr, 'GATEIO:IOTXUSDT')
if sb32
    array.push(buyArr, 'MEXC:KSMUSDT')
if sb33
    array.push(buyArr, 'GATEIO:FILUSDT')
if sb34
    array.push(buyArr, 'BINANCE:WLDUSDT')
if sb35
    array.push(buyArr, 'CRYPTO:GMTUSD')
if sb36
    array.push(buyArr, 'MEXC:IMXUSDT')
if sb37
    array.push(buyArr, 'BINANCE:STXUSDT')
if sb38
    array.push(buyArr, 'BINANCE:FLMUSDT')
if sb39
    array.push(buyArr, 'MEXC:JASMYUSDT')
if sb40
    array.push(buyArr, 'MEXC:ACHUSDT')

if array.size(buyArr) > 0 and barstate.islast
    var atrTable = table.new(position=position.top_right, columns=1, rows=(array.size(buyArr)+1))
    table.set_border_width(atrTable, 1)
    table.set_frame_width(atrTable, 1)
    table.set_border_color(atrTable, tableColor)
    table.set_frame_color(atrTable, tableColor)
   
    for j = 0 to (array.size(buyArr) - 1)
        table.cell(atrTable, 0, j, text=str.tostring(array.get(buyArr, j)), text_color=tableTextHeaderColor, bgcolor=tableBGColor, tooltip="Test")
        table.cell_set_height(atrTable, 0, j, 100 / array.size(buyArr))
        table.cell_set_text_size(atrTable, 0, j, size.auto)
